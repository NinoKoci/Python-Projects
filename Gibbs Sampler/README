1. Introduction:
This is a Gibbs Sampler for CS-167 Homework 3

2. How to run this code:

i. install packages:
    - install numpy as np
    - install sys

ii. Use a command console and insert:
    $ python gibbs.py < insert_file > output
    This format will run in any iteration.

iii. Initial Parameters 
    For this run, we will be using 
            seqs are going to be nucleotide strings. We will try to find the most common motif of k lengths.
            motif_len = 6 This will be the motif length or k,
            alph = [’ A’, ’C’, ’G’, ’T’] the list of nucleotides that we will be analyzing
            lang_prob or the probability of each nucleotide occurring, 
            seed will be a chosen see we will use to run the random state selector we will use to get our initial motifs


iv. How the algorithm runs
    1. parse_FASTA_file(fasta_file); this function will take a FASTA file format and return a list of strings we will use to analyze. In our case, this will return the initial parameter seqs.

    2. class SimpleGibbsSampler()
        a. This class will be initialized with __init__(self, seqs, motif_len, lang, lang_prob, seed), where we will insert our class's initial parameters.
        b. pick_init_positions(): We will select random indexes for each sequence from a random list of sequence lengths—motif_len—so that we always return 6-letter long strings.
        c. motifs_finder(random_idxs,seqs) will return a list of motifs from the sequences for each random index we iterated in the prior function.
        d. build_counts_matrix(motifs), build an np.array of the counts of each nucleotide per position; all values will have the pseudo count of 1 added to them. 
        e. build_prop_matrix(counts_matrix), this function takes the np.array from build_counts_matrix() and divides it by the sum of the column to get the frequencies, and then the language probability 
        g. score_seq_windows(seq, PSSM), this function takes the s* and returns a list of motifs. It will then score all the motifs using the PSSM.
        h. get_msa(self, index_list) takes the iterated index list to return a list of k-long sequences for the number of seqs we have.
        i. run_sampler() runs the Gibbs sampler and returns the iteration number, the final s* removed, the PSSM, and the MSA for the best motifs.

    3. main(), this function will run the parse_FASTA_file(FASTfile), to return the list of seqs, and SimpleGibbsSampler( seqs, motif_len, lang, lang_prob, seed). 
        In the end, we will return the values we get for run_sampler() so that we can get a list
iv. Notes
    To optimally test this function for different seed iterations, manually change the seed in the main() function to either 20 or 14, as these are the seeds in the assignment. 


3. Acknowlegments: 
I want to thank Benson for heling me with the score_seq_windows(seq, PSSM) function.
I also want to acknowlege thi srepositiory for giving me an idea of how a Gibsb sampler operates outide the scope of this function. 
    https://github.com/annapoorna-a-k/MOTIF-DISCOVERY_GIBBS-SAMPLER-using-python/blob/main/gibbs_sampler.py


